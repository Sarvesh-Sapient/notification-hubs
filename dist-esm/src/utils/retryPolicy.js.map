{"version":3,"file":"retryPolicy.js","sourceRoot":"","sources":["../../../src/utils/retryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError, AbortSignal } from \"@azure/abort-controller\";\nimport { delay } from \"@azure/core-amqp\";\nimport { isDefined } from \"./utils.js\";\nimport { isError } from \"@azure/core-util\";\nimport { isRestError } from \"@azure/core-rest-pipeline\";\n\nconst JITTER_FACTOR = 0.08;\n\nfunction isAbortError(e: unknown): e is AbortError {\n  if (e instanceof AbortError) {\n    return true;\n  }\n\n  return isError(e) && e.name === \"AbortError\";\n}\n\n/**\n * Represents the retry delay calculation either fixed or exponential.\n */\nexport enum RetryMode {\n  /**\n   * Fixed interval between retries.\n   */\n  Fixed,\n  /**\n   * Exporation interval between retries.\n   */\n  Exponential,\n}\n\n/**\n * Represents the retry options for an operation.\n */\nexport interface RetryOptions {\n  /**\n   * The retry mode.\n   */\n  mode: RetryMode;\n\n  /**\n   * The number of maximum retries.\n   */\n  maxRetries: number;\n\n  /**\n   * The delay in milliseconds between retries.\n   */\n  delay: number;\n\n  /**\n   * The maximum delay in milliseconds between retries.\n   */\n  maxDelay: number;\n}\n\n/**\n * Creates a set of retry options with defaults.\n * @param options - The options for the retry behavior.\n * @returns The retry options.\n */\nexport function createRetryOptions(options?: Partial<RetryOptions>): RetryOptions {\n  return {\n    mode: RetryMode.Fixed,\n    maxRetries: 3,\n    delay: 1000,\n    maxDelay: 1000 * 60,\n    ...options,\n  };\n}\n\n/**\n * Represents a retry policy with a run operation and define a retry time calculation.\n */\nexport interface RetryPolicy {\n  /**\n   * Calculates the retry delay based upon the error and retry attempt.\n   * @param error - The error from the operation.\n   * @param attempt - The retry attempt number.\n   */\n  calculateRetryDelay: (error: unknown, attempt: number) => number | undefined;\n\n  /**\n   * Runs an operation and retries based upon the retry policy.\n   * @param operation - The operation to run and retry if necessary.\n   * @param signal - An AbortSignal to check for cancellation.\n   * @returns The result of the operation.\n   */\n  runOperation<TResult>(\n    operation: (signal?: AbortSignal) => Promise<TResult>,\n    signal?: AbortSignal\n  ): Promise<TResult>;\n}\n\n/**\n * Creates a base retry policy with the incoming calculateRetryDelay method.\n * @param calculateRetryDelay - The retry calculation behavior based upon attempt number and error.\n * @returns A retry policy with the given calculateRetryDelay method.\n */\nexport function createBaseRetryPolicy(\n  calculateRetryDelay: (error: unknown, attempt: number) => number | undefined\n): RetryPolicy {\n  async function runOperation<TResult>(\n    operation: (signal?: AbortSignal) => Promise<TResult>,\n    signal?: AbortSignal\n  ): Promise<TResult> {\n    let failedAttemptCount = 0;\n\n    while (!signal?.aborted) {\n      try {\n        return await operation(signal);\n      } catch (err) {\n        ++failedAttemptCount;\n        const retryDelay = calculateRetryDelay(err, failedAttemptCount);\n        if (isDefined(retryDelay)) {\n          await delay(retryDelay, signal);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    throw new AbortError(\"The operation has been aborted\");\n  }\n\n  return {\n    calculateRetryDelay,\n    runOperation,\n  };\n}\n\n/**\n * Creates a retry policy configured with the given retry options.\n * @param options - The retry options including delay, max attempts and backoff behavior.\n * @returns A retry policy configured with the given options.\n */\nexport function createDefaultRetryPolicy(options: RetryOptions): RetryPolicy {\n  function calculateRetryDelay(error: unknown, attempt: number): number | undefined {\n    if (\n      options.maxRetries <= 0 ||\n      options.delay === 0 ||\n      options.maxDelay === 0 ||\n      attempt > options.maxRetries ||\n      !shouldRetryError(error)\n    ) {\n      return undefined;\n    }\n\n    const baseJitterSeconds = (options.delay / 1000) * JITTER_FACTOR;\n\n    let retryDelay: number | undefined;\n    if (isRestError(error)) {\n      retryDelay = parseRetryAfter(error.response?.headers.get(\"retry-after\"));\n    }\n\n    if (!isDefined(retryDelay)) {\n      if (options.mode === RetryMode.Exponential) {\n        retryDelay = calculateExponentialDelay(attempt, options.delay / 1000, baseJitterSeconds);\n      } else {\n        retryDelay = calculateFixedDelay(options.delay / 1000, baseJitterSeconds);\n      }\n    }\n\n    if (options.maxDelay < retryDelay) {\n      return options.maxDelay;\n    }\n\n    return retryDelay;\n  }\n\n  return createBaseRetryPolicy(calculateRetryDelay);\n}\n\nfunction parseRetryAfter(headerValue: string | undefined): number | undefined {\n  if (!isDefined(headerValue)) {\n    return undefined;\n  }\n\n  // Retry-After is defined in seconds\n  const number = new Number(headerValue);\n  if (Number.isFinite(number) && number >= 0) {\n    return number.valueOf() * 1000;\n  }\n\n  // Retry-After is defined as a Date\n  const retryDate = Date.parse(headerValue);\n  if (Number.isNaN(retryDate)) {\n    return undefined;\n  }\n\n  const diff = retryDate - Date.now();\n  return diff <= 0 ? undefined : diff;\n}\n\nfunction shouldRetryError(e: unknown): boolean {\n  if (isAbortError(e)) {\n    return false;\n  }\n\n  if (isRestError(e)) {\n    // Throttle and legacy throttle\n    if (e?.statusCode === 429 || e?.statusCode === 403) {\n      return true;\n    }\n    // Network hiccups\n    if (\n      e?.statusCode === 500 ||\n      e?.statusCode === 503 ||\n      e?.statusCode === 504 ||\n      e?.statusCode === 408\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction calculateFixedDelay(baseDelaySeconds: number, baseJitterSeconds: number): number {\n  return (baseDelaySeconds + Math.random() * baseJitterSeconds) * 1000;\n}\n\nfunction calculateExponentialDelay(\n  attemptCount: number,\n  baseDelaySeconds: number,\n  baseJitterSeconds: number\n): number {\n  return (Math.pow(2, attemptCount) * baseDelaySeconds + Math.random() * baseJitterSeconds) * 1000;\n}\n"]}